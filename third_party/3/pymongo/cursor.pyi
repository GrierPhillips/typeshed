import copy
import datetime
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

from collections import deque

from bson import RE_TYPE
from bson.code import Code
from bson.py3compat import (iteritems,
                            integer_types,
                            string_type)
from bson import SON, Code
from pymongo import helpers
from pymongo.common import validate_boolean, validate_is_mapping
from pymongo.collation import Collation, validate_collation_or_none
from pymongo.collection import Collection
from pymongo.errors import (AutoReconnect,
                            ConnectionFailure,
                            InvalidOperation,
                            NotMasterError,
                            OperationFailure)
from pymongo.message import _CursorAddress, _GetMore, _Query, _convert_exception
from pymongo.pool import Pool, SocketInfo
from pymongo.read_preferences import ReadPreference

_QUERY_OPTIONS: Dict[str, int] = {
    "tailable_cursor": 2,
    "slave_okay": 4,
    "oplog_replay": 8,
    "no_timeout": 16,
    "await_data": 32,
    "exhaust": 64,
    "partial": 128}
class CursorType(object):
    NON_TAILABLE: int = 0
    TAILABLE: int = _QUERY_OPTIONS["tailable_cursor"]
    TAILABLE_AWAIT: int = TAILABLE | _QUERY_OPTIONS["await_data"]
    EXHAUST: int = _QUERY_OPTIONS["exhaust"]
class _SocketManager:
    """Used with exhaust cursors to ensure the socket is returned.
    """
    def __init__(self, sock: SocketInfo, pool: Pool) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
class Cursor(object):
    """A cursor / iterator over Mongo query results.
    """

    def __init__(self, collection: Collection, filter: Dict[str, Any] = None,
                 projection: Dict[str, Any] = None, skip: int = 0,
                 limit: int = 0, no_cursor_timeout: bool = False,
                 cursor_type: int = CursorType.NON_TAILABLE,
                 sort: Optional[List[Tuple[str, Any]]] = None,
                 allow_partial_results: bool = False,
                 oplog_replay: bool = False,
                 modifiers: Optional[Dict[str, Any]] = None,
                 batch_size: int = 0, manipulate: bool = True,
                 collation: Optional[Dict[str, Any]] = None) -> None: ...
    @property
    def collection(self) -> Collection: ...
    @property
    def retrieved(self) -> int: ...
    def __del__(self) -> None: ...
    def rewind(self) -> 'Cursor': ...
    def clone(self) -> 'Cursor': ...
    def _clone(self, deepcopy: bool = True) -> 'Cursor': ...
    def _clone_base(self) -> 'Cursor': ...
    def __die(self, synchronous: bool = False) -> None: ...
    def close(self) -> None: ...
    def __query_spec(self) -> Dict[str, Any]: ...
    def __check_okay_to_chain(self) -> None: ...
    def add_option(self, mask: int) -> 'Cursor': ...
    def remove_option(self, mask: int) -> 'Cursor': ...
    def limit(self, limit: int) -> 'Cursor': ...
    def batch_size(self, batch_size: int) -> 'Cursor': ...
    def skip(self, skip: int) -> 'Cursor': ...
    def max_time_ms(self, max_time_ms: int) -> 'Cursor': ...
    def max_await_time_ms(self, max_await_time_ms: int) -> 'Cursor': ...
    def __getitem__(self, index: Union[int, Sequence[int]])\
        -> Union['Cursor', Dict[str, Any]]: ...
    def max_scan(self, max_scan: int) -> 'Cursor': ...
    def max(self, spec: Union[Tuple[str, int], List[Union[str, int]]])\
        -> 'Cursor': ...
    def min(self, spec: Union[Tuple[str, int], List[Union[str, int]]])\
        -> 'Cursor': ...
    def sort(self, key_or_list: Union[str, List[Tuple[str, Union[int, str]]]],
             direction: Optional[Union[int, str]] = None) -> 'Cursor': ...
    def count(self, with_limit_and_skip: bool = False) -> int: ...
    def distinct(self, key: str) -> List[Any]: ...
    def explain(self) -> Dict[str, Any]: ...
    def hint(self, index: Union[str, Tuple[str, Union[int, str]]]): ...
    def comment(self, comment: Union[str, Dict[str, Any]]) -> 'Cursor': ...
    def where(self, code: Union[str, Code]) -> 'Cursor': ...
    def collation(self, collation: Collation) -> 'Cursor': ...
    def __send_message(self, operation: Union[None, _GetMore, _Query])\
        -> None: ...
    def _refresh(self) -> int: ...
    @property
    def alive(self) -> bool: ...
    @property
    def cursor_id(self) -> int: ...
    @property
    def address(self) -> Tuple[str, int]: ...
    def __iter__(self) -> 'Cursor': ...
    def next(self) -> Dict[str, Any]: ...
    def __enter__(self) -> 'Cursor': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __copy__(self) -> 'Cursor': ...
    def __deepcopy__(self, memo: Any) -> 'Cursor': ...
    def _deepcopy(self, x: Dict[str, Any],
                  memo: Optional[Dict[int, Any]] = None)\
        -> Union[List[Any], Dict[Any, Any]]: ...
